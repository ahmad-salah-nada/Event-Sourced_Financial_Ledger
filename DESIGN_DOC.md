# Design Document: Event-Sourced Multi-Currency Financial Ledger

## 1. Introduction

This document outlines the design of a financial ledger system implemented in Go using the event sourcing pattern. The system manages accounts with balances in multiple currencies (USD, EUR, GBP), supports transactions like deposits, withdrawals, currency conversions, and transfers, and provides querying capabilities for account state and history. It prioritizes consistency and auditability by using the sequence of events as the single source of truth. 

## 2. Core Concepts

*   **Event Sourcing**: The system persists the full history of changes as immutable domain events rather than storing the current state directly. The state of an account at any point in time is derived by replaying these events.
*   **Aggregate Root (`Account`)**: The `domain.Account` struct acts as the aggregate root. It encapsulates the account's state (currency balances, version) and enforces business rules through command handlers (`Handle*` methods). All modifications to an account's state are initiated via commands processed by this aggregate.
*   **Command**: Represents an intent to perform an action (e.g., `app.DepositMoneyCommand`). Commands are validated by the `Account` aggregate.
*   **Event**: An immutable record of a state change that has occurred (e.g., `events.DepositMadeEvent`). Events are generated by successful command processing within the `Account` aggregate.
*   **Snapshot**: A persisted representation (`domain.Snapshot`) of the `Account` aggregate's state at a specific version. Snapshots are used to optimize state reconstruction by reducing the number of events that need to be replayed from the `EventStore`.

## 2.1 System Overview (Simplified Flow)

At its core, the system works like this:

1.  **User Interaction**: A user (or the CLI simulation) wants to perform an action (e.g., deposit money) or ask a question (e.g., what's my balance?).
2.  **Commands & Queries**:
    *   Actions become **Commands** (like `DepositMoneyCommand`).
    *   Questions become **Queries** (like `GetBalanceQuery`).
3.  **Application Service (`AccountService`)**: This is the central coordinator.
    *   It receives Commands and Queries.
    *   **For Commands**:
        *   It loads the current state of the specific `Account` by first checking for a recent **Snapshot** and then replaying any **Events** that happened since the snapshot.
        *   It tells the loaded `Account` object to process the Command.
        *   The `Account` checks if the action is valid (e.g., enough funds) and, if so, creates new **Event(s)** describing what changed (e.g., `DepositMadeEvent`).
        *   The `AccountService` saves these new Events to the **Event Store**.
        *   Occasionally, it saves a new **Snapshot** of the `Account`'s state to speed up future loading.
    *   **For Queries**:
        *   It loads the `Account` state (using Snapshots and Events, just like for commands) or directly reads the event history from the **Event Store**.
        *   It extracts the requested information (like balances or event list) and returns it.
4.  **Persistence (`EventStore`, `SnapshotStore`)**: These components (currently in-memory) are responsible for reliably storing and retrieving the Events and Snapshots. The Event Store ensures events are saved in the correct order and detects conflicts if two operations try to change the same account simultaneously based on outdated information (optimistic concurrency).

Essentially, every change is recorded as an event, and the current state is always rebuilt from these events (optimized with snapshots). This provides a full audit trail and ensures consistency.

## 3. High-Level System Flow

The system operates via two primary flows: Command Handling (modifying state) and Query Handling (reading state), orchestrated by the `app.AccountService`.

### 3.1 Command Handling Flow

1.  **Receive Command**: The `AccountService` receives a command struct (e.g., `app.WithdrawMoneyCommand`).
2.  **Load Aggregate (`loadAccount`)**: The service retrieves the target `Account` aggregate's state:
    *   It first attempts to load the latest `Snapshot` from the `store.SnapshotStore`.
    *   If a snapshot is found and successfully applied (`domain.ApplySnapshot`), the `Account` state (ID, Balances, Version) is initialized from the snapshot.
    *   If no snapshot is found or applying it fails, a new, empty `Account` instance (`Version = 0`) is created.
    *   It then retrieves all subsequent `Events` for the `AccountID` from the `store.EventStore` that occurred *after* the snapshot's version (or all events if no snapshot was used) using `GetEventsAfterVersion`.
    *   These events are replayed sequentially onto the `Account` instance using `Account.ApplyEvents`, which calls `Account.ApplyEvent` for each. This updates the `Account`'s state (e.g., `Balances`) and increments its `Version`.
3.  **Execute Command**: The `AccountService` calls the corresponding handler method on the loaded `Account` aggregate (e.g., `account.HandleWithdraw(...)`). For currency conversions or transfers involving different currencies, it first retrieves the necessary exchange rate using `getExchangeRate` (currently a dummy implementation).
4.  **Validate & Generate Events**: The `Account.Handle*` method validates the command against business rules (e.g., sufficient funds, positive amounts). If valid, it creates one or more new `Event` objects (e.g., `events.WithdrawalMadeEvent`), applies them internally using `ApplyEvent` (mutating state and incrementing `Version`), and stores them in the transient `changes` slice.
5.  **Persist Events**: The `AccountService` retrieves the uncommitted events using `account.GetUncommitedChanges()`. It then attempts to save these events to the `store.EventStore` using `SaveEvents`, providing the `Account`'s version *before* the new events were applied as the `expectedVersion`.
6.  **Optimistic Concurrency Check**: The `store.InMemoryEventStore` checks if the provided `expectedVersion` matches the last known version for that `AccountID` in its internal stream map. If not, it returns `store.ErrOptimisticLock`, failing the operation. Otherwise, it appends the new events to the stream.
7.  **Create Snapshot (`saveSnapshotIfNeeded`)**: After successfully saving events, the `AccountService` checks if the `Account`'s *new* version is an exact multiple of `app.SnapshotFrequency` (currently 100) and greater than 0. If true, it calls `domain.CreateSnapshot` to serialize the `Account`'s current state into JSON and saves the resulting `Snapshot` object to the `store.SnapshotStore`.
8.  **Return Result**: The service returns success or an error to the caller (`main.go`).

### 3.2 Query Handling Flow

1.  **Receive Query**: The `AccountService` receives a query struct (e.g., `app.GetBalanceQuery`, `app.GetHistoryQuery`).
2.  **Load State / History**:
    *   For state queries (`GetCurrentBalance`): The service loads the `Account` aggregate using the full `loadAccount` process described in Command Handling Step 2 (snapshot + event replay).
    *   For history queries (`GetTransactionHistory`): The service directly retrieves the full event stream for the `AccountID` from the `store.EventStore` using `GetEvents`. It then applies pagination (`Skip`, `Limit`) to the result.
3.  **Return Data**: The service extracts the requested information (balances map or a slice of events) and returns it. Queries do not modify state or generate events.

## 4. Domain Model (`domain` package)

*   **`Account` (Aggregate Root)**:
    *   `ID`: Unique account identifier (string, typically UUID).
    *   `Balances`: `map[shared.Currency]decimal.Decimal` holding the amount for each currency.
    *   `Version`: Integer tracking the aggregate's version, incremented by each applied event. Used for optimistic concurrency and state reconstruction.
    *   `changes`: Transient `[]events.Event` slice holding newly generated, uncommitted events.
    *   **Behavior**:
        *   `Handle*` methods: Validate commands and generate events (e.g., `HandleDeposit`, `HandleWithdraw`, `HandleCreateAccount`, `HandleConvertCurrency`, `HandleTransferMoney`).
        *   `ApplyEvent`: Mutates the `Account` state based on the event type. Contains the core state transition logic. Ensures invariants (e.g., non-negative balances) after applying an event.
        *   `ApplyEvents`: Iteratively calls `ApplyEvent` for a slice of events (used during reconstruction).
        *   `GetUncommitedChanges`: Returns and clears the `changes` slice.
        *   `getBalance`: Helper to safely get a balance, returning zero for non-held currencies.
*   **`Money` (Value Object)**:
    *   `Amount`: `decimal.Decimal` for precise calculations.
    *   `Currency`: `shared.Currency`.
    *   **Behavior**: Provides type-safe arithmetic (`Add`, `Subtract`) and comparison (`GreaterThan`, `GreaterThanOrEqual`, `IsZero`, etc.), ensuring operations only occur between matching currencies.
*   **`Balance` (Value Object - `shared` package)**:
    *   `Currency`: `shared.Currency`.
    *   `Amount`: `decimal.Decimal`.
    *   Primarily used within the `AccountCreatedEvent` payload.
*   **`Currency` (Type - `shared` package)**:
    *   `shared.Currency` (string type alias).
    *   Constants define supported currencies (`USD`, `EUR`, `GBP`).
*   **`Transaction` (Implicit)**: Transactions are not explicitly modeled but are represented by the domain events themselves (e.g., `DepositMadeEvent`, `MoneyTransferredEvent`).
*   **`Snapshot`**:
    *   `AggregateID`, `Version`, `Timestamp`.
    *   `State`: `[]byte` containing the JSON-serialized `Account` state.
    *   **Behavior**: `CreateSnapshot` serializes an `Account` instance. `ApplySnapshot` deserializes the `State` back into an `Account` instance.

## 5. Event Definitions (`events` package)

Events are immutable records of state changes, embedding `events.BaseEvent` (`EventID`, `AggregateID`, `Version`, `Timestamp`, `Type`).

*   **`AccountCreatedEvent`**: Fired on account creation.
    *   `InitialBalances`: `[]shared.Balance` detailing starting balances.
*   **`DepositMadeEvent`**: Fired when funds are added.
    *   `Amount`: `decimal.Decimal`.
    *   `Currency`: `shared.Currency`.
*   **`WithdrawalMadeEvent`**: Fired when funds are removed.
    *   `Amount`: `decimal.Decimal`.
    *   `Currency`: `shared.Currency`.
*   **`CurrencyConvertedEvent`**: Fired on internal currency conversion.
    *   `FromAmount`, `FromCurrency`: Source details.
    *   `ToAmount`, `ToCurrency`: Target details.
    *   `ExchangeRate`: `decimal.Decimal` rate used.
*   **`MoneyTransferredEvent`**: Fired when the *debit* part of a transfer occurs from the source account.
    *   `TargetAccountID`: ID of the intended recipient.
    *   `DebitedAmount`, `DebitedCurrency`: Amount/currency removed from the source.
    *   `CreditedAmount`, `CreditedCurrency`: Amount/currency intended for the target (calculated based on `ExchangeRate` if currencies differ).
    *   `ExchangeRate`: `decimal.Decimal` rate used (1 for same-currency).
*   **`ExchangeRateUpdatedEvent`**: *Defined but not implemented or used*. Intended to record changes in exchange rates over time. The current implementation uses a hardcoded, stateless `getExchangeRate` function in `AccountService`.

## 6. State Reconstruction (`app.loadAccount`)

The state of an `Account` aggregate is reconstructed from its event stream and snapshots:
1.  **Load Snapshot**: Attempt to retrieve the latest `Snapshot` for the `AccountID` from the `SnapshotStore`.
2.  **Apply Snapshot**: If found, deserialize the snapshot state (`domain.ApplySnapshot`) to initialize the `Account` instance and set its version. Log errors and fall back to step 3 if deserialization fails.
3.  **Initialize Empty Account**: If no snapshot is found or loading/applying fails, create a new `Account` instance with version 0 (`domain.NewAccount`).
4.  **Load Subsequent Events**: Retrieve all events for the `AccountID` from the `EventStore` whose version is *greater than* the snapshot version (or all events if version is 0) using `GetEventsAfterVersion`.
5.  **Replay Events**: Apply the retrieved events sequentially to the `Account` instance using `Account.ApplyEvents`. Each `ApplyEvent` call updates the `Balances` and increments the `Version`.
6.  **Check Existence**: After loading, if the `Account.Version` is still 0, it means no creation event was found, and `domain.ErrAccountNotFound` is returned.
7.  **Return State**: The fully reconstructed `Account` object is returned.

## 7. Snapshotting Strategy (`app.saveSnapshotIfNeeded`)

Snapshots optimize state reconstruction for accounts with long event histories.
*   **Trigger**: A snapshot is taken *after* events are successfully saved to the `EventStore` if the aggregate's *new* version is an exact multiple of `app.SnapshotFrequency` (constant, currently 100) and the version is greater than 0.
*   **Creation**: `domain.CreateSnapshot` is called with the current `Account` instance. It serializes the `Account` struct (including `ID`, `Balances`, `Version`) into a JSON byte slice.
*   **Storage**: The resulting `Snapshot` object (containing ID, version, timestamp, and the JSON state) is saved to the `SnapshotStore` (`store.InMemorySnapshotStore`). The store overwrites any previous snapshot for the same `AggregateID`.
*   **Frequency Tradeoff**: The frequency (100) balances the cost of snapshot creation/storage against the time saved during state reconstruction. Lower frequency means more frequent snapshots but faster loads; higher frequency means fewer snapshots but potentially longer loads.

## 8. Querying (`app.GetCurrentBalance`, `app.GetTransactionHistory`)

Queries provide read access to account information without altering state.
*   **`GetCurrentBalance`**:
    1.  Loads the `Account` aggregate using the full state reconstruction process (`loadAccount`), potentially utilizing snapshots.
    2.  Returns a *copy* of the `Balances` map (or just the requested currency's balance if specified in the query).
    3.  Returns `domain.ErrAccountNotFound` if `loadAccount` indicates the account doesn't exist.
*   **`GetTransactionHistory`**:
    1.  Retrieves the full event stream for the `AccountID` directly from the `EventStore` using `GetEvents`.
    2.  If the stream is empty, it performs a `loadAccount` check to differentiate between an empty history for an existing account and a non-existent account, returning `domain.ErrAccountNotFound` if applicable.
    3.  Applies pagination (`Skip`, `Limit`) to the retrieved event slice.
    4.  Returns the resulting slice of `events.Event`.
*   **Consistency**: Queries achieve read consistency by reconstructing state from the persisted events (the source of truth), either fully or starting from a snapshot.

## 9. Architecture Overview

The system employs a layered architecture:

*   **`main.go` (Entrypoint/Simulation)**: Initializes dependencies (`InMemoryEventStore`, `InMemorySnapshotStore`, `AccountService`) and runs a sequence of operations (create, deposit, withdraw, convert, transfer, query) to demonstrate functionality. Acts as a basic CLI driver.
*   **`app` (Application Layer)**:
    *   `AccountService`: Orchestrates command handling and querying. Mediates between the domain and persistence layers. Contains application-specific logic like snapshot triggering and dummy exchange rate lookup.
    *   `Commands`/`Queries`: Data structures defining the inputs for service methods.
*   **`domain` (Domain Layer)**:
    *   `Account`: Aggregate root containing core business logic and state transitions.
    *   `Money`, `Snapshot`: Supporting domain objects.
    *   `Errors`: Custom domain errors (`ErrInsufficientFunds`, `ErrAccountExists`, `ErrAccountNotFound`).
*   **`events` (Events Layer)**:
    *   Defines the `Event` interface, `BaseEvent`, specific event structs, and `EventType` constants.
*   **`store` (Persistence Layer)**:
    *   `EventStore`: Interface and `InMemoryEventStore` implementation for saving/retrieving event streams. Handles optimistic concurrency checks.
    *   `SnapshotStore`: Interface and `InMemorySnapshotStore` implementation for saving/retrieving aggregate snapshots.
*   **`shared` (Shared Kernel)**:
    *   Contains common types (`Currency`, `Balance`) used across multiple layers.

## 10. Technology Stack

*   **Language**: Go (Golang) v1.24.1
*   **Libraries**:
    *   `github.com/shopspring/decimal`: For precise, arbitrary-precision decimal arithmetic, crucial for financial calculations.
    *   `github.com/google/uuid`: For generating unique event IDs (and potentially account IDs if not provided).
*   **Persistence**: In-memory implementations (`store.InMemoryEventStore`, `store.InMemorySnapshotStore`) are used for simplicity and demonstration. These are suitable for testing but would be replaced by database-backed implementations (e.g., PostgreSQL, EventStoreDB) in a production environment. Standard Go `encoding/json` is used for snapshot serialization.

## 11. CLI Interface (`main.go`)

The `main.go` file serves as the interface and demonstration driver. It directly interacts with the `AccountService` to:
*   Create accounts (`Alice`, `Bob`, `Snapshot Test Account`).
*   Perform operations: Deposit, Withdraw (including testing insufficient funds), Convert Currency, Transfer Money (simulating debit and credit separately).
*   Query state: Display final balances and transaction history for accounts using helper functions (`displayBalances`, `displayHistory`).
*   Demonstrate snapshotting: Creates an account and applies enough events (`SnapshotFrequency + 5`) to trigger snapshot creation, then verifies by reloading the account.
